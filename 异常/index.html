<!doctype html>
<html lang="en-us">
  <head>
    <title>异常 // My New Hugo Site</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.65.3" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="John Doe" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://maosuxi.github.io/css/main.min.f90f5edd436ec7b74ad05479a05705770306911f721193e7845948fb07fe1335.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="异常"/>
<meta name="twitter:description" content="异常：一种导致程序中断执行的指令流。 try{ //可能出现异常的语句 }[catch(异常类型 异常对象){ }catch(异常类型 异常对象){ }&hellip;] [finally{ //不管是否异常都要执行 }] try&hellip;catch、try&hellip;catch&hellip;finally、try&hellip;finally 获取异常的全部信息可以使用异常类的printStackTrace()方法。 public class Test { public static void main(String [] args){ System.out.println(&ldquo;1.&mdash;&mdash;&mdash;&mdash;&mdash;&quot;); try { int x=Integer.parseInt(args[0]); int y=Integer.parseInt(args[1]); System.out.println(&ldquo;2.&mdash;&mdash;&mdash;-&ldquo;&#43;(x/y)); } catch(ArithmeticException e){ e.printStackTrace(); } System.out.println(&ldquo;3.&mdash;&mdash;&mdash;&mdash;&mdash;&quot;); } } 即便有了异常处理语句，但是如果没有进行正确的异常捕获，那么程序也会导致中断，finally类的代码依然会执行，这样就必须使用多个异常捕获 处理多个异常 public static void main(String [] args){ Scanner in=new Scanner(System.in); System.out.println(&ldquo;1.&mdash;&mdash;&mdash;&mdash;&mdash;&quot;); try { int x=in.nextInt(); int y=in.nextInt(); System.out.println(&ldquo;2.&mdash;&mdash;&mdash;-&ldquo;&#43;(x/y)); } catch(ArithmeticException e){ e.printStackTrace(); } catch(InputMismatchException e){ e.printStackTrace(); } catch(ArrayIndexOutOfBoundsException e){ //System.out.println(e); e."/>

    <meta property="og:title" content="异常" />
<meta property="og:description" content="异常：一种导致程序中断执行的指令流。 try{ //可能出现异常的语句 }[catch(异常类型 异常对象){ }catch(异常类型 异常对象){ }&hellip;] [finally{ //不管是否异常都要执行 }] try&hellip;catch、try&hellip;catch&hellip;finally、try&hellip;finally 获取异常的全部信息可以使用异常类的printStackTrace()方法。 public class Test { public static void main(String [] args){ System.out.println(&ldquo;1.&mdash;&mdash;&mdash;&mdash;&mdash;&quot;); try { int x=Integer.parseInt(args[0]); int y=Integer.parseInt(args[1]); System.out.println(&ldquo;2.&mdash;&mdash;&mdash;-&ldquo;&#43;(x/y)); } catch(ArithmeticException e){ e.printStackTrace(); } System.out.println(&ldquo;3.&mdash;&mdash;&mdash;&mdash;&mdash;&quot;); } } 即便有了异常处理语句，但是如果没有进行正确的异常捕获，那么程序也会导致中断，finally类的代码依然会执行，这样就必须使用多个异常捕获 处理多个异常 public static void main(String [] args){ Scanner in=new Scanner(System.in); System.out.println(&ldquo;1.&mdash;&mdash;&mdash;&mdash;&mdash;&quot;); try { int x=in.nextInt(); int y=in.nextInt(); System.out.println(&ldquo;2.&mdash;&mdash;&mdash;-&ldquo;&#43;(x/y)); } catch(ArithmeticException e){ e.printStackTrace(); } catch(InputMismatchException e){ e.printStackTrace(); } catch(ArrayIndexOutOfBoundsException e){ //System.out.println(e); e." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://maosuxi.github.io/%E5%BC%82%E5%B8%B8/" />
<meta property="article:published_time" content="2020-05-09T23:59:49+08:00" />
<meta property="article:modified_time" content="2020-05-09T23:59:49+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://maosuxi.github.io"><img class="app-header-avatar" src="/avatar.jpg" alt="John Doe" /></a>
      <h1>My New Hugo Site</h1>
      <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc vehicula turpis sit amet elit pretium.</p>
      <div class="app-header-social">
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">异常</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          May 9, 2020
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          2 min read
        </div></div>
    </header>
    <div class="post-content">
      <p>异常：一种导致程序中断执行的指令流。
try{
//可能出现异常的语句
}[catch(异常类型 异常对象){
}catch(异常类型 异常对象){
}&hellip;] [finally{
//不管是否异常都要执行
}]
try&hellip;catch、try&hellip;catch&hellip;finally、try&hellip;finally
获取异常的全部信息可以使用异常类的printStackTrace()方法。
public class Test {
public static void main(String [] args){
System.out.println(&ldquo;1.&mdash;&mdash;&mdash;&mdash;&mdash;&quot;);
try {
int x=Integer.parseInt(args[0]);
int y=Integer.parseInt(args[1]);
System.out.println(&ldquo;2.&mdash;&mdash;&mdash;-&ldquo;+(x/y));
} catch(ArithmeticException e){
e.printStackTrace();
}
System.out.println(&ldquo;3.&mdash;&mdash;&mdash;&mdash;&mdash;&quot;);
}
}
即便有了异常处理语句，但是如果没有进行正确的异常捕获，那么程序也会导致中断，finally类的代码依然会执行，这样就必须使用多个异常捕获
处理多个异常
public static void main(String [] args){
Scanner in=new Scanner(System.in);
System.out.println(&ldquo;1.&mdash;&mdash;&mdash;&mdash;&mdash;&quot;);
try {
int x=in.nextInt();
int y=in.nextInt();
System.out.println(&ldquo;2.&mdash;&mdash;&mdash;-&ldquo;+(x/y));
} catch(ArithmeticException e){
e.printStackTrace();
}
catch(InputMismatchException e){
e.printStackTrace();
}
catch(ArrayIndexOutOfBoundsException e){
//System.out.println(e);
e.printStackTrace();
}
System.out.println(&ldquo;3.&mdash;&mdash;&mdash;&mdash;&mdash;&quot;);
}
}
1.在程序运行的过程中才会产生异常，而一旦程序执行过程中产生异常之后将自动进行指定类型的异常类对象实例化处理
2.如果此时程序之中并没有提供有异常处理的支持，则会采用JVM的默认异常处理方式，首先打印异常信息的打印，而后退出程序
3.如果存在异常处理，那么这个产生的异常类的实例化对象将会被try语句所捕获
4.try捕获到异常后与其匹配的catch中的异常类型进行依次的比对，匹配则进行相应的处理，如果没有任何的匹配成功则表示该异常无法进行处理。
5.不管异常是否处理都要执行finall语句，当执行完finall语句后会进一步判断当前的异常是否被处理，如处理过了继续执行后面的代码，如果没有处理则交由JVM进行相应的处理。
整个异常处理流程操作的是一个异常类的实例化对象
Error:此时程序还未出现异常，开发者无法处理
Exception:程序中出现的异常，开发者可以处理（开发者需要关注的）
所有的异常都可以交给Exception处理：
public class Test {
public static void main(String [] args){
Scanner in=new Scanner(System.in);
System.out.println(&ldquo;1.&mdash;&mdash;&mdash;&mdash;&mdash;&quot;);
try {
int x=(Integer)in.nextInt();
int y=in.nextInt();
System.out.println(&ldquo;2.&mdash;&mdash;&mdash;-&ldquo;+(x/y));
} catch(Exception e){
e.printStackTrace();
}
System.out.println(&ldquo;3.&mdash;&mdash;&mdash;&mdash;&mdash;&quot;);
}
}
当不确定可能产生哪些异常的时候，这种处理方式最方便，但是同时也会有问题：描述的错误信息不明确导致不好调试。分开处理是一种更加明确的处理方式。
进行多个异常同时处理的时候，捕获范围大的异常必须放在捕获范围小的异常后面
throws关键字
在方法定义上使用的，表示将此方法中可能产生的异常明确告诉给调用处。使用throws关键字必须对异常进行捕捉或声明以便抛出
throw关键字
在代码块中使用，手工进行异常的抛出，表示此时将产生一个异常类的实例化对象，并且进行异常的抛出处理</p>
<p>import java.util.Scanner;
public class Test_1 {
public static int div(int x,int y)throws Exception {
System.out.println(&quot;【开始】&quot;);
int temp=0;
try {
temp=x/y;//调用处处理异常
}catch(Exception e) {//catch代码块可省略，简化为try&hellip;finally代码块
throw e;//向上抛异常对象（手工进行异常的抛出）
}finally {
System.out.println(&quot;【结束】&quot;);}
return temp;
}
public static void main(String [] args){
Scanner in=new Scanner(System.in);
System.out.println(&ldquo;1.&mdash;&mdash;&mdash;&mdash;&mdash;&quot;);
try {
System.out.println(Test_1.div(10, 0));
} catch(Exception e){
e.printStackTrace();
}
}
}</p>
<p>RuntimeException标注的异常可以不强制进行处理</p>
<p>自定义异常类
有两种实现方案，继承Exception或者继承RuntimeException
class BoomException extends Exception{
public BoomException(String msg) {
super(msg);
}
}
class Food{
public static void eat(int total) throws Exception {
if(total&gt;10) {
throw new BoomException(&ldquo;吃太多了，肚子撑了！&quot;);
}else if(total&lt;10){
System.out.println(&ldquo;还能继续吃&rdquo;);
}else {
System.out.println(&ldquo;饱了，不能吃了&rdquo;);
}
}
}
public class Test{</p>
<p>public static void main(String [] args)throws Exception {
Food.eat(10);
}
}</p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
